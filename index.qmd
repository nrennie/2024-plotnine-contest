---
title: "Annotated area charts"
subtitle: "A visualisation of coal production data for the 2024 `plotnine` contest"
author: "Nicola Rennie"
format:
  html: 
    theme: lux
    toc: true
    highlight-style: pygments
---

[Plotnine](https://plotnine.org/) is a visualisation library that brings the Grammar of Graphics to Python, and the [2024 Plotnine Contest](https://posit.co/blog/announcing-the-2024-plotnine-contest/) aims to bring the community together to create and share with others great `plotnine` examples! In this tutorial, I'll be walking you through the process of creating the following plot for my entry into the `plotnine` contest!

![](plot.png)

This entry for the `plotnine` contest was inspired by a visualisation I previously created using `{ggplot2}` in R for [#TidyTuesday](https://github.com/rfordatascience/tidytuesday/blob/master/data/2024/2024-05-21/readme.md). You can see the original R version at [github.com/nrennie/tidytuesday/tree/main/2024/2024-05-21](https://github.com/nrennie/tidytuesday/tree/main/2024/2024-05-21).

# Preparing for plotting

Before we dive into plotting, we need to get some data and tidy it up!

## Python libraries

Let's start by loading the Python libraries that we'll need to create the plot. Beyond `plotnine` for actually plotting, we also need `pandas` for data wrangling, `textwrap` for wrapping long strings of text, `matplotlib.pyplot` for some additional plot tinkering, `highlight_text` for adding coloured and bold text to annotations, and `matplotlib.font_manager` for dealing with fonts.

```{python}
import plotnine as gg
import pandas as pd
import textwrap
import matplotlib.pyplot as plt
import highlight_text as ht
import matplotlib.font_manager
```

## Reading in data

The data set we'll be using is the *Carbon Majors* emissions data. As I mentioned earlier, this dataset is used as a [#TidyTuesday dataset](https://github.com/rfordatascience/tidytuesday/blob/master/data/2024/2024-05-21/readme.md). This means we can read the data in directly from the #TidyTuesday GitHub repository:

```{python}
emissions = pd.read_csv(
    'https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-05-21/emissions.csv')
```

You can download the `emissions.csv` file from GitHub if you prefer to load the data from a local file. There's also a copy of the `emissions.csv` file in the `data` folder of the [GitHub repository](https://github.com/nrennie/2024-plotnine-contest) for this tutorial - just in case!

Carbon Majors is a database of historical production data from 122 of the world’s largest oil, gas, coal, and cement producers. The dataset has 12,551 rows and 7 columsn with the following variables: `year`, `parent_entity`, `parent_type`, `commodity`, `production_value`, `production_unit`, and `total_emissions_MtCO2e`. The #TidyTuesday [README](https://github.com/rfordatascience/tidytuesday/blob/master/data/2024/2024-05-21/readme.md#emissionscsv) file has more information on what the variables are.

## Data wrangling

For this plot, let's focus on emissions relating to coal only, There are six different types of coal in the data set and we'll filter the rows to keep only rows relating to those six types of coal. We'll also remove the word `"Coal"` from each of the category labels since it will be obvious they are types of coal.

```{python}
# Prep data for plotting
plot_data = emissions[
    emissions['commodity'].isin([
        'Sub-Bituminous Coal', 'Metallurgical Coal', 'Bituminous Coal',
        'Thermal Coal', 'Anthracite Coal', 'Lignite Coal'
    ])
].copy()
plot_data['commodity'] = plot_data['commodity'].str.replace(' Coal', '')
```

We'll also focus on production levels, so we'll keep only the columns we need to plot: year, type of coal (`commodity`), and amount produced (`production_value`). The data README tells us that the `production_value` column is given in million tonnes for coal production.

We also need to sum up production across the different entities to get a total production value per year. We'll also filter the data to consider only the years since 1900:

```{python}
plot_data = plot_data[['year', 'commodity', 'production_value']]
plot_data = plot_data.groupby(['year', 'commodity'], as_index=False).agg(
    {'production_value': 'sum'}).rename(columns={'production_value': 'n'})
plot_data = plot_data[plot_data['year'] >= 1900]
```

Let's also sort the categories based on their production amount in the last year of the data (2022), to make out plot a little bit clearer:

```{python}
# Sort values by 2022 levels
orders = plot_data[plot_data['year'] == 2022].sort_values(
    by='n', ascending=False)['commodity']
plot_data['commodity'] = pd.Categorical(
    plot_data['commodity'],
    categories=orders,
    ordered=True)
```

We're going to be adding some annotations to the plot, and one of the annotations will show the first year that production exceeded 100 million tonnes per year. Let's calculate that year (and therefore the position of the annotation) in a data-driven way:

```{python}
# Values for annotations
exceeds100 = plot_data.groupby('year')['n'].sum()
exceeds100 = exceeds100[exceeds100 > 100].index.min()
```

I often find that traditional grid lines make a plot look a little bit too *busy*. Instead, we're going to create our own *grid lines* by drawing some vertical lines. To do this, let's create some data with the desired positions of where the vertical lines hit the x-axis:

```{python}
# Create data for x-axis labels
segment_data = pd.DataFrame({
    'year': list(range(1900, 2021, 20))
})
```

We'll do something similar with the y-axis, by creating custom labels that encompass both the values and the units - rather than having a separate y-axis title. We'll put these values on the right hand side of the plot (rather than the left as normal) because this is often where people's eyes end up looking when they're reading a chart of data over time.

```{python}
# y-axis labels
y_axis_data = pd.DataFrame({
    'value': [0, 2000, 4000, 6000, 8000],
    'label': ['0', '2,000', '4,000', '6,000', '8,000\nmillion\ntonnes']
})
```

## Colour, font, and text variables

To make it easier to change up colour schemes, it's useful to define colours as variables. Here, we define a background colour (`bg_col`), a text colour (`text_col`), and a colour palette that will be used to colour the different areas.

```{python}
# Define background colour, text colour, and colour palette
bg_col = '#FFFFFA'
text_col = '#0D5C63'
col_palette = [
    '#E58606',
    '#5D69B1',
    '#52BCA3',
    '#99C945',
    '#CC61B0',
    '#24796C']
```

Similarly, we can define variable(s) for which font we want to use. But we also need to make sure that the font we want is actually available. We can get a list of available fonts using `matplotlib.font_manager.findSystemFonts()`. 

```{python}
# Check if 'Arial' in list of installed fonts
flist = matplotlib.font_manager.findSystemFonts()
# names = [matplotlib.font_manager.FontProperties(
#     fname=fname).get_name() for fname in flist]
```

If `'Arial'` is installed, we'll use that as the main font (`body_font`) and if not, we'll use the default sans serif font.

```{python}
# if 'Arial' in names:
#     body_font = 'Arial'
# else:
#     body_font = 'sans'
body_font = 'sans'
```

> If you're running this code on your own laptop, feel free to choose a different font!

Let's also create some variables to store our title and subtitle text. Although these could be passed straight into title and subtitle arguments in the plotting function, keeping them separated keeps the plotting code looking a little bit cleaner. The subtitle text is also quite long, so we'll use `textwrap.wrap()` to wrap the text to 50 characters (without breaking words onto multiple lines):

```{python}
# title, subtitle
title_text = 'Coal production since 1900'
st = 'Carbon Majors is a database of historical production data from 122 of the world’s largest oil, gas, coal, and cement producers. This data is used to quantify the direct operational emissions and emissions from the combustion of marketed products that can be attributed to these entities.'
wrapped_subtitle = '\n'.join(textwrap.wrap(st, width=50))
```

Instead of a traditional legend, we're going to use coloured text to show how which categories the different colours map to. We're going to prepare some text that we'll use later in functions from the `highlight-text` library. 

We create a string as normal with the text we want to display, then format words within the strings in the following way:

```{python}
#| eval: false
'Normal text then <coloured text::{"color": "red"}>'
```

Instead, of `"red"` we can use our different hex colours. We also add line breaks using `\n`. We'll also add some text formatting to the caption in a similar way. Instead of colouring the text, we'll make some of it bold. Therefore, we use `"fontweight": "bold"` instead of `"color": "red"`:

```{python}
# annotation labels
coal_types_label = 'Total coal production includes\nproduction of <Bituminous::{"color": "#E58606"}>,\n<Sub-bituminous::{"color": "#5D69B1"}>, <Metallurgical::{"color": "#52BCA3"}>,\n<Lignite::{"color": "#99C945"}>, <Anthracite::{"color": "#CC61B0"}>, and <Thermal::{"color": "#24796C"}>\ncoal. Bituminous accounts\nfor around half.'

# caption
cap = '<Data::{"fontweight": "bold"}>: Carbon Majors\n<Graphic::{"fontweight": "bold"}>: Nicola Rennie (@nrennie)'
```

Now we're ready to plot!

# Plotting with `plotnine`

```{python}
p = (gg.ggplot(plot_data, gg.aes(x='year', y='n')) +
     # Axis lines
     gg.geom_segment(data=segment_data, mapping=gg.aes(x='year', xend='year', y=0, yend=-1700),
                     linetype='dashed', alpha=0.4, color=text_col) +
     # Axis labels
     gg.geom_text(data=segment_data, mapping=gg.aes(x='year', y=-1900, label='year'),
                  color=text_col, size=8, family=body_font, ha='left') +
     gg.geom_text(data=y_axis_data, mapping=gg.aes(x=2023, y='value', label='label'),
                  color=text_col, size=8, family=body_font, ha='left', va='top'))
```

```{python}
#| echo: false
#| eval: true
p + gg.theme(figure_size = (8, 6))
```

```{python}
p = (p +
     # Annotation 1
     gg.annotate(
         'segment',
         x=exceeds100, xend=exceeds100,
         y=0, yend=5000,
         size=1,
         color=text_col
) +
    gg.annotate(
         'text',
         x=exceeds100 + 2, y=5000,
         label=exceeds100,
         color=text_col,
         family=body_font,
         ha='left',
         va='top',
         size=10,
         fontweight='bold'
) +
    gg.annotate(
         'text',
         x=exceeds100 + 2, y=5000 - 600,
         label='Total coal production first\nexceeds 100 million tonnes\nper year.',
         color=text_col,
         family=body_font,
         ha='left',
         size=9,
         va='top'
) +
    # Annotation 2
    gg.annotate(
         'segment',
         size=1,
         x=1975, xend=1975,
         y=0, yend=10000,
         color=text_col
) +
    gg.annotate(
         'text',
         x=1975 + 2, y=10000,
         label='Coal types',
         color=text_col,
         family=body_font,
         ha='left',
         va='top',
         size=10,
         fontweight='bold'
))
```

```{python}
#| echo: false
#| eval: true
p + gg.theme(figure_size = (8, 6))
```

Let's finally add the area chart!

```{python}
p = (p +
    # Area plot
    gg.geom_area(gg.aes(fill='commodity')) +
    # Scales
    gg.scale_fill_manual(values=col_palette) +
    gg.scale_x_continuous(limits=(1896, 2034)) +
    gg.scale_y_continuous(limits=(-3300, 12000)) +
    # Text for title and subtitle
    gg.annotate(
         'text',
         x=1900, y=11400,
         label=title_text,
         color=text_col,
         family=body_font,
         ha='left',
         va='top',
         size=13,
         fontweight='bold'
) +
    gg.annotate(
         'text',
         x=1900, y=10500,
         label=wrapped_subtitle,
         color=text_col,
         family=body_font,
         size=9.5,
         ha='left',
         va='top'
))
```

```{python}
#| echo: false
#| eval: true
p + gg.theme(figure_size = (8, 6))
```

Let's add some final styling with `plotnine` by trimming the white space between the plot and the axis using `coord_cartesian(expand=False)`. In `plotnine` (and {ggplot2} in R) themese are used to control the styling of all non-data related elements e.g. the background colour, the grid lines, and so on. We add `theme_void()` to remove all axes, gridlines, and unwanted text. Then we add a little bit more styling using different arguments of `theme()` where we remove the legend, and set the background colour to the variable we defined earlier. Note that the background elements use `element_rect` since the background is essentially just a big rectangle!

```{python}
p = (p +
    # Styling
    gg.coord_cartesian(expand=False) +
    gg.theme_void(base_size=8) +
    gg.theme(
         legend_position='none',
         plot_background=gg.element_rect(fill=bg_col, color=bg_col),
         panel_background=gg.element_rect(fill=bg_col, color=bg_col)
))
```

Here's what our plot looks like now:

```{python}
#| echo: false
#| eval: true
p + gg.theme(figure_size = (8, 6))
```

We still need to add the caption, and the coloured text as an alternative to a traditional legend. Unfortunately, there isn't currently a native way in `plotnine` to add coloured text through `highlight-text`, but we can just add it on top directly. 

## Applying text styling with `highlight-text`

```{python}
# Add coloured text with matplotlib and highlight-text
fig = p.draw()
fig.set_size_inches(8, 6, forward=True)
fig.set_dpi(300)
ax = plt.gca()
ht.ax_text(
    1977,
    9400,
    coal_types_label,
    vsep=3,
    color=text_col,
    fontname=body_font,
    fontsize=9,
    va='top')
ht.ax_text(1900, -2300, cap, color=text_col,
           fontname=body_font, fontsize=7.5, va='top')
plt.show()
```

If you want to save our plot to a file, we can use `plt.savefig()` and specify the resolution and `bbox_inches='tight'` to avoid any extra whitespace around the edges of the plot.

```{python}
#| eval: false
# Save image
plt.savefig('plot.png', dpi=300, bbox_inches='tight')
```

Check out the [`plotnine` Gallery](https://plotnine.org/gallery/) for more examples of plots created using `plotnine`!
